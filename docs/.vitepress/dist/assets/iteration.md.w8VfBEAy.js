import{_ as a,o as n,c as i,ag as e}from"./chunks/framework.CbQjVMS6.js";const c=JSON.parse('{"title":"Iteration","description":"","frontmatter":{"title":"Iteration"},"headers":[],"relativePath":"iteration.md","filePath":"iteration.md"}'),t={name:"iteration.md"};function l(r,s,p,o,h,g){return n(),i("div",null,[...s[0]||(s[0]=[e(`<h1 id="iteration" tabindex="-1">Iteration <a class="header-anchor" href="#iteration" aria-label="Permalink to &quot;Iteration&quot;">​</a></h1><p>It is possible to iterate over the following things:</p><ul><li><a href="#nodes">Nodes</a></li><li><a href="#edges">Edges</a></li><li><a href="#neighbors">Neighbors</a></li></ul><p><strong>Iteration methods</strong></p><p>The library basically proposes three ways to iterate:</p><ul><li>Methods returning arrays of keys.</li><li>Methods using callbacks.</li><li>Methods creating JavaScript iterable <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noreferrer">iterators</a> for lazy consumption.</li></ul><h2 id="nodes" tabindex="-1">Nodes <a class="header-anchor" href="#nodes" aria-label="Permalink to &quot;Nodes&quot;">​</a></h2><p>Those methods iterate over the graph&#39;s nodes.</p><p><strong>Examples</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Elizabeth&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the array-returning method:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Elizabeth&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the callback method</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, attributes);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using functional-style iteration method</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> degrees</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">degree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the iterator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nodeEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, attributes);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="nodes-array">#.nodes</h3><p>Returns an array of node keys.</p><h3 id="foreachnode" tabindex="-1">#.forEachNode <a class="header-anchor" href="#foreachnode" aria-label="Permalink to &quot;#.forEachNode&quot;">​</a></h3><p>Iterates over each node using a callback.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="mapnodes" tabindex="-1">#.mapNodes <a class="header-anchor" href="#mapnodes" aria-label="Permalink to &quot;#.mapNodes&quot;">​</a></h3><p>Returns an array containing the result of a callback applied on each node of the graph.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="filternodes" tabindex="-1">#.filterNodes <a class="header-anchor" href="#filternodes" aria-label="Permalink to &quot;#.filterNodes&quot;">​</a></h3><p>Returns an array of node keys for which the given predicate function returned <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: predicate to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="reducenodes" tabindex="-1">#.reduceNodes <a class="header-anchor" href="#reducenodes" aria-label="Permalink to &quot;#.reduceNodes&quot;">​</a></h3><p>Returns the accumulated result of applying a callback combining our current value with a computation evaluated on each node of the graph.</p><p>Contrary to JavaScript <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noreferrer">Array.reduce</a>, you must provide it because the callback takes more than one argument and we cannot infer the initial value from our first iteration.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li><li><strong>initialValue</strong> <span class="code">any</span>: the initial value to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>accumulator</strong> <span class="code">any</span>: the accumulated value.</li><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="findnode" tabindex="-1">#.findNode <a class="header-anchor" href="#findnode" aria-label="Permalink to &quot;#.findNode&quot;">​</a></h3><p>Returns the key of the first node matching given predicate function or <code>undefined</code> if no matching node could be found.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: predicate to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="somenode" tabindex="-1">#.someNode <a class="header-anchor" href="#somenode" aria-label="Permalink to &quot;#.someNode&quot;">​</a></h3><p>Returns whether any node in the graph matches the given predicate function.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: predicate to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="everynode" tabindex="-1">#.everyNode <a class="header-anchor" href="#everynode" aria-label="Permalink to &quot;#.everyNode&quot;">​</a></h3><p>Returns whether all nodes in the graph match the given predicate function.</p><p><strong>Arguments</strong></p><ul><li><strong>callback</strong> <span class="code">function</span>: predicate to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h3 id="nodeentries" tabindex="-1">#.nodeEntries <a class="header-anchor" href="#nodeentries" aria-label="Permalink to &quot;#.nodeEntries&quot;">​</a></h3><p>Returns an iterator over the graph&#39;s nodes.</p><p><strong>Entries</strong></p><ul><li><strong>node</strong> <span class="code">string</span>: the node&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the node&#39;s attributes.</li></ul><h2 id="edges" tabindex="-1">Edges <a class="header-anchor" href="#edges" aria-label="Permalink to &quot;Edges&quot;">​</a></h2><p>These methods iterate over the graph&#39;s edges.</p><p><strong>Examples</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;R&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Rosaline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;E&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Emmett&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C-&gt;T&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;R-&gt;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Rosaline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;J-&gt;D1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdgeWithKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;J-&gt;D2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the array-returning methods:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;R&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;E&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C-&gt;T&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;R-&gt;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;R&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T-&gt;E&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C-&gt;T&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;J-&gt;D1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;J-&gt;D2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the callback methods</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sourceAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">targetAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Edge from \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// And the counterparts to target a node or path&#39;s edges</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using functional-style iteration method</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapEdges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> attr.weight;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the iterators</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ...} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edgeEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(edge, attributes);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="edges-array">#.edges</h3><p>Returns an array of relevant edge keys.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.inEdges</span></span>
<span class="line"><span>#.outEdges</span></span>
<span class="line"><span>#.inboundEdges (in + undirected)</span></span>
<span class="line"><span>#.outboundEdges (out + undirected)</span></span>
<span class="line"><span>#.directedEdges</span></span>
<span class="line"><span>#.undirectedEdges</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>None</strong>: iterate over every edge.</li><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li></ul><h3 id="foreachedge" tabindex="-1">#.forEachEdge <a class="header-anchor" href="#foreachedge" aria-label="Permalink to &quot;#.forEachEdge&quot;">​</a></h3><p>Iterates over relevant edges using a callback.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.forEachInEdge</span></span>
<span class="line"><span>#.forEachOutEdge</span></span>
<span class="line"><span>#.forEachInboundEdge (in + undirected)</span></span>
<span class="line"><span>#.forEachOutboundEdge (out + undirected)</span></span>
<span class="line"><span>#.forEachDirectedEdge</span></span>
<span class="line"><span>#.forEachUndirectedEdge</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="mapedges" tabindex="-1">#.mapEdges <a class="header-anchor" href="#mapedges" aria-label="Permalink to &quot;#.mapEdges&quot;">​</a></h3><p>Returns an array containing the result of a callback applied on the relevant edges.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.mapInEdges</span></span>
<span class="line"><span>#.mapOutEdges</span></span>
<span class="line"><span>#.mapInboundEdges (in + undirected)</span></span>
<span class="line"><span>#.mapOutboundEdges (out + undirected)</span></span>
<span class="line"><span>#.mapDirectedEdges</span></span>
<span class="line"><span>#.mapUndirectedEdges</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="filteredges" tabindex="-1">#.filterEdges <a class="header-anchor" href="#filteredges" aria-label="Permalink to &quot;#.filterEdges&quot;">​</a></h3><p>Returns an array of edge keys for which the given predicate function returned <code>true</code>.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.filterInEdges</span></span>
<span class="line"><span>#.filterOutEdges</span></span>
<span class="line"><span>#.filterInboundEdges (in + undirected)</span></span>
<span class="line"><span>#.filterOutboundEdges (out + undirected)</span></span>
<span class="line"><span>#.filterDirectedEdges</span></span>
<span class="line"><span>#.filterUndirectedEdges</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="reduceedges" tabindex="-1">#.reduceEdges <a class="header-anchor" href="#reduceedges" aria-label="Permalink to &quot;#.reduceEdges&quot;">​</a></h3><p>Returns the accumulated result of applying a callback combining our current value with a computation evaluated on the relevant edges.</p><p>Contrary to JavaScript <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noreferrer">Array.reduce</a>, you must provide it because the callback takes more than one argument and we cannot infer the initial value from our first iteration.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.reduceInEdges</span></span>
<span class="line"><span>#.reduceOutEdges</span></span>
<span class="line"><span>#.reduceInboundEdges (in + undirected)</span></span>
<span class="line"><span>#.reduceOutboundEdges (out + undirected)</span></span>
<span class="line"><span>#.reduceDirectedEdges</span></span>
<span class="line"><span>#.reduceUndirectedEdges</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li><li><strong>initialValue</strong> <span class="code">any</span>: the initial value to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li><li><strong>initialValue</strong> <span class="code">any</span>: the initial value to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li><li><strong>initialValue</strong> <span class="code">any</span>: the initial value to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>accumulator</strong> <span class="code">any</span>: the accumulated value.</li><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="findedge" tabindex="-1">#.findEdge <a class="header-anchor" href="#findedge" aria-label="Permalink to &quot;#.findEdge&quot;">​</a></h3><p>Returns the key of the first edge matching given predicate function or <code>undefined</code> if no matching node could be found.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.findInEdge</span></span>
<span class="line"><span>#.findOutEdge</span></span>
<span class="line"><span>#.findInboundEdge (in + undirected)</span></span>
<span class="line"><span>#.findOutboundEdge (out + undirected)</span></span>
<span class="line"><span>#.findDirectedEdge</span></span>
<span class="line"><span>#.findUndirectedEdge</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="someedge" tabindex="-1">#.someEdge <a class="header-anchor" href="#someedge" aria-label="Permalink to &quot;#.someEdge&quot;">​</a></h3><p>Returns whether any edge in the graph matches the given predicate function.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.someInEdge</span></span>
<span class="line"><span>#.someOutEdge</span></span>
<span class="line"><span>#.someInboundEdge (in + undirected)</span></span>
<span class="line"><span>#.someOutboundEdge (out + undirected)</span></span>
<span class="line"><span>#.someDirectedEdge</span></span>
<span class="line"><span>#.someUndirectedEdge</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="everyedge" tabindex="-1">#.everyEdge <a class="header-anchor" href="#everyedge" aria-label="Permalink to &quot;#.everyEdge&quot;">​</a></h3><p>Returns whether all edges in the graph match the given predicate function.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.everyInEdge</span></span>
<span class="line"><span>#.everyOutEdge</span></span>
<span class="line"><span>#.everyInboundEdge (in + undirected)</span></span>
<span class="line"><span>#.everyOutboundEdge (out + undirected)</span></span>
<span class="line"><span>#.everyDirectedEdge</span></span>
<span class="line"><span>#.everyUndirectedEdge</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Callback</strong>: iterate over every edge.</li></ol><ul><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="2"><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li><li><strong>undirected</strong> <span class="code">boolean</span>: whether the edge is undirected.</li></ul><h3 id="edgeentries" tabindex="-1">#.edgeEntries <a class="header-anchor" href="#edgeentries" aria-label="Permalink to &quot;#.edgeEntries&quot;">​</a></h3><p>Returns an iterator over relevant edges.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.inEdgeEntries</span></span>
<span class="line"><span>#.outEdgeEntries</span></span>
<span class="line"><span>#.inboundEdgeEntries (in + undirected)</span></span>
<span class="line"><span>#.outboundEdgeEntries (out + undirected)</span></span>
<span class="line"><span>#.directedEdgeEntries</span></span>
<span class="line"><span>#.undirectedEdgeEntries</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>None</strong>: iterate over every edge.</li><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant attached edges.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the related node&#39;s key.</li></ul><ol start="3"><li><strong>Using source &amp; target</strong>: will iterate over the relevant edges going from source to target.</li></ol><ul><li><strong>source</strong> <span class="code">any</span>: the source node&#39;s key.</li><li><strong>target</strong> <span class="code">any</span>: the target node&#39;s key.</li></ul><p><strong>Entries</strong></p><ul><li><strong>edge</strong> <span class="code">string</span>: the edge&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the edge&#39;s attributes.</li><li><strong>source</strong> <span class="code">string</span>: key of the edge&#39;s source.</li><li><strong>target</strong> <span class="code">string</span>: key of the edge&#39;s target.</li><li><strong>sourceAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s source.</li><li><strong>targetAttributes</strong> <span class="code">object</span>: attributes of the edge&#39;s target.</li></ul><h2 id="neighbors" tabindex="-1">Neighbors <a class="header-anchor" href="#neighbors" aria-label="Permalink to &quot;Neighbors&quot;">​</a></h2><p>These methods iterate over the neighbors of the given node or nodes.</p><p><strong>Examples</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Rosaline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Emmett&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Rosaline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mergeEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Daniel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the array-returning methods</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">neighbors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Rosaline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Emmett&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the callback methods</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachNeighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Thomas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">neighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(neighbor, attributes);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using functional-style iteration method</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> neighborDegress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapNeighbors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">neighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">degree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(neighbor);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Using the iterators</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">neighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">neighborEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(neighbor, attributes);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="neighbors-array">#.neighbors</h3><p>Returns an array of relevant neighbor keys.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.inNeighbors</span></span>
<span class="line"><span>#.outNeighbors</span></span>
<span class="line"><span>#.inboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.outboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.directedNeighbors</span></span>
<span class="line"><span>#.undirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li></ul><h3 id="foreachneighbor" tabindex="-1">#.forEachNeighbor <a class="header-anchor" href="#foreachneighbor" aria-label="Permalink to &quot;#.forEachNeighbor&quot;">​</a></h3><p>Iterates over the relevant neighbors using a callback.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.forEachInNeighbor</span></span>
<span class="line"><span>#.forEachOutNeighbor</span></span>
<span class="line"><span>#.forEachInboundNeighbor (in + undirected)</span></span>
<span class="line"><span>#.forEachOutboundNeighbor (out + undirected)</span></span>
<span class="line"><span>#.forEachDirectedNeighbor</span></span>
<span class="line"><span>#.forEachUndirectedNeighbor</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="mapneighbors" tabindex="-1">#.mapNeighbors <a class="header-anchor" href="#mapneighbors" aria-label="Permalink to &quot;#.mapNeighbors&quot;">​</a></h3><p>Returns an array containing the result of a callback applied on the relevant neighbors.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.mapInNeighbors</span></span>
<span class="line"><span>#.mapOutNeighbors</span></span>
<span class="line"><span>#.mapInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.mapOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.mapDirectedNeighbors</span></span>
<span class="line"><span>#.mapUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li><li></li></ul><h3 id="filterneighbors" tabindex="-1">#.filterNeighbors <a class="header-anchor" href="#filterneighbors" aria-label="Permalink to &quot;#.filterNeighbors&quot;">​</a></h3><p>Returns an array of neighbor keys for which the given predicate function returned <code>true</code>.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.filterInNeighbors</span></span>
<span class="line"><span>#.filterOutNeighbors</span></span>
<span class="line"><span>#.filterInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.filterOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.filterDirectedNeighbors</span></span>
<span class="line"><span>#.filterUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="reduceneighbors" tabindex="-1">#.reduceNeighbors <a class="header-anchor" href="#reduceneighbors" aria-label="Permalink to &quot;#.reduceNeighbors&quot;">​</a></h3><p>Returns the accumulated result of applying a callback combining our current value with a computation evaluated on the relevant neighbors.</p><p>Contrary to JavaScript <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noreferrer">Array.reduce</a>, you must provide it because the callback takes more than one argument and we cannot infer the initial value from our first iteration.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.reduceInNeighbors</span></span>
<span class="line"><span>#.reduceOutNeighbors</span></span>
<span class="line"><span>#.reduceInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.reduceOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.reduceDirectedNeighbors</span></span>
<span class="line"><span>#.reduceUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li><li><strong>initialValue</strong> <span class="code">any</span>: the initial value to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>accumulator</strong> <span class="code">any</span>: the accumulated value.</li><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="findneighbor" tabindex="-1">#.findNeighbor <a class="header-anchor" href="#findneighbor" aria-label="Permalink to &quot;#.findNeighbor&quot;">​</a></h3><p>Returns the key of the first neighbor matching given predicate function or <code>undefined</code> if no matching node could be found.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.findInNeighbors</span></span>
<span class="line"><span>#.findOutNeighbors</span></span>
<span class="line"><span>#.findInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.findOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.findDirectedNeighbors</span></span>
<span class="line"><span>#.findUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="someneighbor" tabindex="-1">#.someNeighbor <a class="header-anchor" href="#someneighbor" aria-label="Permalink to &quot;#.someNeighbor&quot;">​</a></h3><p>Returns whether any neighbor in the graph matches the given predicate function.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.someInNeighbors</span></span>
<span class="line"><span>#.someOutNeighbors</span></span>
<span class="line"><span>#.someInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.someOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.someDirectedNeighbors</span></span>
<span class="line"><span>#.someUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="everyneighbor" tabindex="-1">#.everyNeighbor <a class="header-anchor" href="#everyneighbor" aria-label="Permalink to &quot;#.everyNeighbor&quot;">​</a></h3><p>Returns whether all neighbors in the graph match the given predicate function.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.everyInNeighbors</span></span>
<span class="line"><span>#.everyOutNeighbors</span></span>
<span class="line"><span>#.everyInboundNeighbors (in + undirected)</span></span>
<span class="line"><span>#.everyOutboundNeighbors (out + undirected)</span></span>
<span class="line"><span>#.everyDirectedNeighbors</span></span>
<span class="line"><span>#.everyUndirectedNeighbors</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li><li><strong>callback</strong> <span class="code">function</span>: callback to use.</li></ul><p><strong>Callback arguments</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul><h3 id="neighborentries" tabindex="-1">#.neighborEntries <a class="header-anchor" href="#neighborentries" aria-label="Permalink to &quot;#.neighborEntries&quot;">​</a></h3><p>Returns an iterator over the relevant neighbors.</p><p><strong>Variants</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#.inNeighborEntries</span></span>
<span class="line"><span>#.outNeighborEntries</span></span>
<span class="line"><span>#.inboundNeighborEntries (in + undirected)</span></span>
<span class="line"><span>#.outboundNeighborEntries (out + undirected)</span></span>
<span class="line"><span>#.directedNeighborEntries</span></span>
<span class="line"><span>#.undirectedNeighborEntries</span></span></code></pre></div><p><strong>Arguments</strong></p><ol><li><strong>Using a node&#39;s key</strong>: will iterate over the node&#39;s relevant neighbors.</li></ol><ul><li><strong>node</strong> <span class="code">any</span>: the node&#39;s key.</li></ul><ol start="2"><li><strong>Using two nodes&#39; keys</strong>: will return whether the two given nodes are neighbors.</li></ol><ul><li><strong>node1</strong> <span class="code">any</span>: first node.</li><li><strong>node2</strong> <span class="code">any</span>: second node.</li></ul><p><strong>Entries</strong></p><ul><li><strong>neighbor</strong> <span class="code">string</span>: the neighbor&#39;s key.</li><li><strong>attributes</strong> <span class="code">object</span>: the neighbor&#39;s attributes.</li></ul>`,253)])])}const k=a(t,[["render",l]]);export{c as __pageData,k as default};
