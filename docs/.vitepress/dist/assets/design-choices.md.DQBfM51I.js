import{_ as i,o as e,c as a,ag as n}from"./chunks/framework.CbQjVMS6.js";const g=JSON.parse('{"title":"Design choices","description":"","frontmatter":{"title":"Design choices"},"headers":[],"relativePath":"design-choices.md","filePath":"design-choices.md"}'),t={name:"design-choices.md"};function h(l,s,d,r,p,o){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="design-choices" tabindex="-1">Design choices <a class="header-anchor" href="#design-choices" aria-label="Permalink to &quot;Design choices&quot;">​</a></h1><h2 id="keys" tabindex="-1">Keys <a class="header-anchor" href="#keys" aria-label="Permalink to &quot;Keys&quot;">​</a></h2><p>Both nodes &amp; edges are represented by keys in the graph. For simplicity&#39;s sake, like JavaScript&#39;s native objects, the graph will always coerce the given keys as strings.</p><p>We could technically handle references as keys but finally decided against it for the following reasons:</p><ul><li>Ensure that serialization remains as straightforward as possible.</li><li>Not to put a pressure on end-users&#39; code by having to force the usage of, for instance, ES6 Maps to ensure their code will handle every Graph case possible.</li></ul><p>This said, the user should keep in mind that the graph have the same quirks as a JavaScript native object:</p><ul><li>Numbers as keys will be coerced to strings.</li><li>Giving objects as keys will result in a <code>[object Object]</code> key etc.</li></ul><h2 id="addedge-as-sugar" tabindex="-1">#.addEdge as sugar <a class="header-anchor" href="#addedge-as-sugar" aria-label="Permalink to &quot;#.addEdge as sugar&quot;">​</a></h2><p>As explained in the <a href="#keys">keys</a> section above, <em>all</em> edges must have a key in a <code>graphology</code> instance.</p><p>Unfortunately it can be tedious to force users to provide their own key each time they want to add an edge to the graph. And even if edge keys can be very practical sometimes - especially with multigraphs - users do not even care about those in simpler use-cases since they can still reach those edges through their source &amp; target very easily.</p><p>So to make sure <code>graphology</code> remains convenient to use, we added an <a href="./mutation#addedge"><code>#.addEdge</code></a> method that actually automatically creates a key for the user and returns it.</p><p>As such, this method should be considered as <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noreferrer">sugar</a> as it will not create a special kind of edge that would be different than any other one stored within a <code>graphology</code> instance.</p><p>This means, for instance, that serialized edges exported from <code>graphology</code> will always have a key and that this key outlives the current instance if you want to use it in a direct copy, or across runtimes.</p><p>This decision seemed the best to us, in a Social Network Analysis context where serialization and portability across many tools is to be ensured and where many paradigms coexists regarding the identification of edges in a graph, with or without a key, sometimes even both.</p><p>Here are two other solutions that we considered at one point but finally dismissed:</p><ol><li><u>Distinguishing between edges having a key and edges without one.</u><br>We did not choose this solution because, even if edges without keys can be accessed through their source &amp; target, it makes edge indexing outside a graph (as it is often the case in outside library when aggregating metrics, for instance) very painful.</li><li><u>Using ES6 Symbol as keys for edges created without one.</u><br>We did not choose this solution for the following reasons: <ol><li>This would mean that those keys would be instance-specific or at least runtime-specific.</li><li>This would usually lead to mixed-type indexing (both symbols and strings) in objects or maps outside of the graph and those are often badly optimized by most JS engines.</li><li>Symbols are not very well known by most JS developers and have many quirks, such as the fact they are not enumerable which can very easily confuse beginners.</li></ol></li><li><u>Using number keys for edges created without one.</u><br>We did not choose this solution for the same reasons as symbols, namely mixed indexing, the quirkiness of it all and the fact that JavaScript has a tradition of coercing object keys to strings that would make them unfit for external indexing of edges.</li></ol><h2 id="mixed-graphs-type-precedence" tabindex="-1">Mixed graphs &amp; type precedence <a class="header-anchor" href="#mixed-graphs-type-precedence" aria-label="Permalink to &quot;Mixed graphs &amp; type precedence&quot;">​</a></h2><p>When using mixed graphs, one should consider that directed edges will always take precedence over the undirected ones.</p><p>Use the typed methods to solve the ambiguity.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;graphology&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This will add a directed edge</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Same as:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addDirectedEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This will add an undirected edge</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addUndirectedEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// So, for instance, if you need to target the undirected edge</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUndirectedEdgeAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;LIKES&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="errors" tabindex="-1">Errors <a class="header-anchor" href="#errors" aria-label="Permalink to &quot;Errors&quot;">​</a></h2><p>Rather than failing silently, <code>graphology</code> API will often throw errors to notify the developer that something inconsistent was performed so they can fix their code.</p><p><code>graphology</code> errors are designed to be as helpful as possible to help the developer fix the issue. For instance, the implementation will gladly tell you not to use the <code>#.addUndirectedEdge</code> method on a <code>directed</code> graph and point you towards the <code>#.addEdge</code> or <code>#.addDirectedEdge</code> method instead.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {DirectedGraph} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;graphology&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DirectedGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Lucy&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addUndirectedEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Lucy&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Catherine&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Error </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`DirectedGraph.addUndirectedEdge: You cannot add an undirected edge.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">to a directed graph Use the #.addEdge or #.addDirectedEdge method instead.\`</span></span></code></pre></div><h2 id="chaining" tabindex="-1">Chaining <a class="header-anchor" href="#chaining" aria-label="Permalink to &quot;Chaining&quot;">​</a></h2><p>By convention, you can assume that if the documentation does not tell you what a specific method returns then it will return the instance itself for chaining purposes.</p><p>One might note that, contrary to some other libraries, <code>graphology</code> returns the node or edge on the <code>#.addNode</code> &amp; <code>#.addEdge</code> method rather than enabling chaining methods. This was made so that the &quot;get/has&quot; pattern remains usable and to avoid unnecessary reads of the graph when building one.</p><h2 id="concerning-order" tabindex="-1">Concerning order <a class="header-anchor" href="#concerning-order" aria-label="Permalink to &quot;Concerning order&quot;">​</a></h2><p>The user should not expect the <code>Graph</code> to retain insertion order. It might be a side effect of the used implementation to retain an order but it is not guaranteed by the specification.</p><p>However, if no node/edge was added or dropped from the graph, the order should remain stable from one iteration to the next.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;First Node&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Second Node&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Won&#39;t necessarily print &#39;First Node&#39; then &#39;Second Node&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Might be the other way around.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="polling-edges" tabindex="-1">Polling edges <a class="header-anchor" href="#polling-edges" aria-label="Permalink to &quot;Polling edges&quot;">​</a></h2><p>Note that two different ways are generally accessible to you when targeting edges in the graph:</p><ul><li>Either you can provide their key.</li><li>Or you can use their source &amp; target to find them.</li></ul><p>Note however that, since graph instances can support parallel edges, you might sometimes want to avoid using the second way since it will throw if you handle a multi-graph.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Graph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Eric&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Martha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Adding our edge</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Eric&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Martha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Now we can see if the edge exists either by key:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(edge);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or by source &amp; target:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Eric&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Martha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><h2 id="avoiding-methods-affecting-indexing-constraints" tabindex="-1">Avoiding methods affecting indexing constraints <a class="header-anchor" href="#avoiding-methods-affecting-indexing-constraints" aria-label="Permalink to &quot;Avoiding methods affecting indexing constraints&quot;">​</a></h2><p>TL;DR: we won&#39;t be adding methods like <code>#.renameNode</code>, <code>#.renameEdge</code> or <code>#.setNodeExtremities</code> etc.</p><p>Indeed, even though is possible to expose methods able to change a node&#39;s key, or even an edge&#39;s extremities, we decided against it for the following reasons:</p><ol><li>It affects indexing constraints that may be enforced outside of the graph, using events for instance, and this needlessly complexify what you need to react to when developing external indexations of the graphs. For instance, instead of <code>addNode</code> and <code>dropNode</code> one would also be required to handle something like <code>renameNode</code>.</li><li>In most languages, one is not able to change dictionary keys. But you can still somehow do it by deleting the key and add its value using another one. You can also do so with a <code>Graph</code>, even if it can feel more cumbersome. But under the hood, since the internal indices will need to update this unique key constraint, an internal method would probably amount to the same operations.</li></ol><p>Finally, note that <a href="./standard-library/utils"><code>graphology-utils</code></a> exposes helpers for those kind of scenarios such as the <a href="./standard-library/utils#renamegraphkeys"><code>renameGraphKeys</code></a> function.</p><h2 id="order-of-undirected-edge-extremities" tabindex="-1">Order of undirected edge extremities <a class="header-anchor" href="#order-of-undirected-edge-extremities" aria-label="Permalink to &quot;Order of undirected edge extremities&quot;">​</a></h2><p>By convention, undirected edge extremities are recorded in the order they were first provided by the user.</p><p>Also, it can be surprising but when iterating over undirected edges, the argument given as source may not be the node from which we are iterating from:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEachUndirectedEdge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Sometimes true, sometimes false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>Indeed, we chose to guarantee that the &quot;source&quot; &amp; the &quot;target&quot; will always be the same when accessing information about an undirected edge.</p><p>This means that, even if this feels arbitrary because source &amp; target are irrelevant for an undirected edge, the <a href="./read#source"><code>#.source</code></a> method will always return the same node, and will always be referenced as this edge&#39;s source when iterating, even from a node.</p><p>It could be nice sugar to reorder source &amp; target of undirected edges in iteration but it would definitely be confusing or make no sense in some scenarios as <code>graphology</code> Graphs can be many things. For instance, let&#39;s consider the case when we want to iterate over inbound (undirected + in) or even all edges in a mixed graph.</p>`,48)])])}const c=i(t,[["render",h]]);export{g as __pageData,c as default};
